# BLS12-381 Solana Native instruction

This is a README for the new functionality added by Eclipse
Laboratories Inc. pertaining to the BLS12-381 single signature verify.

## Overview
The BLS12 curve is different to most Edwards-based encryption
algorithms, specifically it does not have a natural affine basis, by
that we mean that each party participating in signature/encryption
must also choose a starting point with sufficient entropy.  In
addition to that, the BLS curve algorithms have poor performance when
ported to BPF, specifically because there isn't an efficient
instruction that would map two 64-bit integers into a single 128-bit
integer.  This effectively precludes its inclusion upstream for the
foreseeable future.  Further, the current implementation cannot be
considered API-stable as it has not undergone an audit, and it has
some limitations (particularly, it doesn't take into account threshold
signatures, n/n multi-signature schemes, as well as many other
features unique to BLS12-381).

With that said, this document shall contain an overview needed for
both internal review, and external usage.  Without further ado. 

## Implementation

The current implementation relies on the Apache-Milagro Library
version 3, ported to Rust (`amcl = 0.2.1`).  While there have been
alternative implementations, they were ruled out because of a
combination of not being maintained, not being complete and not having
undergone an audit. 

The current implementation, however, had been based on Apache-Milagro
of version 2, and had been copied verbatim from the most prominent
implementation as part of Hyperledger Ursa.  Thus, while it has not
been actively maintained since 2021, it has been audited, and is based
on a cryptography library that is both complete and has a longer
development cycle, thus lending to easier maintenance. 

The library itself cannot be included as a dependency because of the
restrictions that it would impose on the entire Solana SDK, and the
potential performance impact of using `amcl` of an earlier version
without the constant-time implementations for most operations.
Further, the library had been retired in favour of a larger number of
smaller implementations, of which this can be considered one.

Almost all of the new code is contained in the
`./sdk/src/bls12_381_instruction.rs` rust module, and re-exported
through the SDK.  Additional tests are added in the `programs`, to
verify that the signature verification works as expected.

### Keys and Signatures

This module defines the following types: `KeyPair`, which contains a
`SignKey` and `VerKey`, and a `Signature` type.  The nomenclature is
deliberately different from the regular cryptography to emphasise the
API-instability as well as the slightly different roles that these
keys play in the BLS12 context as opposed to the Edwards-family.  The
structures are give as much ABI-stability as possible, and their
fixed-size representations are controlled via the `FixedByteRepr`
trait.  Their sizes must not be altered, otherwise, undefined
behaviour can be invoked. 

The main useful traits are implemented, if a trait is missing, it has
been omitted deliberately.  Particularly, the `Ord` and `Eq` family
are implemented to the maximal extent that does not defy intuition.
With that said, sometimes, two signatures can be identical, but fail
to verify, while at the same time, two different `Signature`
structures can be representations of the same group element. 

The size of most structures is given as an integer factor of something
known as `MODBYTES`, which is canonically set to be `32` bytes.  The
largest structures are derived from `G1` group elements, which are the
size of `16*32 = 512` bytes, or half a kilobyte. With that said,
because the size is almost always fixed, it is recommended to avoid
indirection when handling objects of type `Signature`, and instead
rely on the stack representation as much as possible. 


### Usage walk through

#### GeneratorPoint

The test `sig_verify` in the same module is a detailed explanation of
the usual steps involved in using a BLS12-381 signature scheme.

Firstly, as opposed to the Edwards family of encryption curves, all
parties should agree on an initial `GeneratorPoint`.  This value is
vital to the operation of the entire encryption scheme and everyone
participating in the sig-verify handshake must be made aware of the
exact same generator point.  If the parties disagree on the generator
point, their signatures, and keys cannot be used interchangeably.

An implementation of `core::default::Default` is provided for the
`GeneratorPoint` for testing purposes only.  One is strongly advised
to improve the strength of the encryption by using a more complex seed
phrase.  While it is tempting to seed the phrase with the name of
one's application, or the network name, the minimum entropy needed for
`GeneratorPoint** is at least 128 **bytes**.  It is usually much
better to create a `random_seed` and share that.  Do not throw away
the `GeneratorPoint` after use, unless you know what you're doing. 

```rust
/// This is not a cryptographically safe seed, and it should **never**
/// be hard-coded into your program, but rather stored securely and
/// imported when necessary.
let GENERATOR_POINT_SEED = [1_u8; 128];

fn init () -> {
    // ...
    let generator_point = GeneratorPoint::from_seed(&GENERATOR_POINT_SEED);
}

```

#### KeyPair

Using a `GeneratorPoint` one can generate a pair of keys, which can
then be tracked together or separately. This is for the use-case of 
