# BLS12-381 Solana Native instruction

This is a README for the new functionality added by Eclipse
Laboratories Inc. pertaining to the BLS12-381 single signature verify.

## Overview
The BLS12 curve is different to most Edwards-based encryption
algorithms, specifically it does not have a natural affine basis, by
that we mean that each party participating in signature/encryption
must also choose a starting point with sufficient entropy.  In
addition to that, the BLS curve algorithms have poor performance when
ported to BPF, specifically because there isn't an efficient
instruction that would map two 64-bit integers into a single 128-bit
integer.  This effectively precludes its inclusion upstream for the
foreseeable future.  Further, the current implementation cannot be
considered API-stable as it has not undergone an audit, and it has
some limitations (particularly, it doesn't take into account threshold
signatures, n/n multi-signature schemes, as well as many other
features unique to BLS12-381).

With that said, this document shall contain an overview needed for
both internal review, and external usage.  Without further ado. 

## Implementation

The current implementation relies on the Apache-Milagro Library
version 3, ported to Rust (`amcl = 0.2.1`).  While there have been
alternative implementations, they were ruled out because of a
combination of not being maintained, not being complete and not having
undergone an audit. 

The current implementation, however, had been based on Apache-Milagro
of version 2, and had been copied verbatim from the most prominent
implementation as part of Hyperledger Ursa.  Thus, while it has not
been actively maintained since 2021, it has been audited, and is based
on a cryptography library that is both complete and has a longer
development cycle, thus lending to easier maintenance. 

The library itself cannot be included as a dependency because of the
restrictions that it would impose on the entire Solana SDK, and the
potential performance impact of using `amcl` of an earlier version
without the constant-time implementations for most operations.
Further, the library had been retired in favour of a larger number of
smaller implementations, of which this can be considered one.

Almost all of the new code is contained in the
`./sdk/src/bls12_381_instruction.rs` rust module, and re-exported
through the SDK.  Additional tests are added in the `programs`, to
verify that the signature verification works as expected.

### Keys and Signatures

This module defines the following types: `KeyPair`, which contains a
`SignKey` and `VerKey`, and a `Signature` type.  The nomenclature is
deliberately different from the regular cryptography to emphasise the
API-instability as well as the slightly different roles that these
keys play in the BLS12 context as opposed to the Edwards-family.  The
structures are give as much ABI-stability as possible, and their
fixed-size representations are controlled via the `FixedByteRepr`
trait.  Their sizes must not be altered, otherwise, undefined
behaviour can be invoked. 

The main useful traits are implemented, if a trait is missing, it has
been omitted deliberately.  Particularly, the `Ord` and `Eq` family
are implemented to the maximal extent that does not defy intuition.
With that said, sometimes, two signatures can be identical, but fail
to verify, while at the same time, two different `Signature`
structures can be representations of the same group element. 

The size of most structures is given as an integer factor of something
known as `MODBYTES`, which is canonically set to be `32` bytes.  The
largest structures are derived from `G1` group elements, which are the
size of `16*32 = 512` bytes, or half a kilobyte. With that said,
because the size is almost always fixed, it is recommended to avoid
indirection when handling objects of type `Signature`, and instead
rely on the stack representation as much as possible. 


### Usage walk through

#### GeneratorPoint

The test `sig_verify` in the same module is a detailed explanation of
the usual steps involved in using a BLS12-381 signature scheme.

Firstly, as opposed to the Edwards family of encryption curves, all
parties should agree on an initial `GeneratorPoint`.  This value is
vital to the operation of the entire encryption scheme and everyone
participating in the sig-verify handshake must be made aware of the
exact same generator point.  If the parties disagree on the generator
point, their signatures, and keys cannot be used interchangeably.

An implementation of `core::default::Default` is provided for the
`GeneratorPoint` for testing purposes only.  One is strongly advised
to improve the strength of the encryption by using a more complex seed
phrase.  While it is tempting to seed the phrase with the name of
one's application, or the network name, the minimum entropy needed for
`GeneratorPoint** is at least 128 **bytes**.  It is usually much
better to create a `random_seed` and share that.  Do not throw away
the `GeneratorPoint` after use, unless you know what you're doing. 

```rust
/// This is not a cryptographically safe seed, and it should **never**
/// be hard-coded into your program, but rather stored securely and
/// imported when necessary.
let GENERATOR_POINT_SEED = [1_u8; 128];

fn init () -> {
    // ...
    let generator_point = GeneratorPoint::from_seed(&GENERATOR_POINT_SEED);
}

```

#### KeyPair

Using a `GeneratorPoint` one can generate a pair of keys, which can
then be tracked together or separately. This is for the use-case of
dispensing the keys in one location, or creating session keys. 

However, often it is necessary to generate a private key from a seed
phrase, and then to be able to generate various public keys for
various applications, such that the user only need track one key for
multiple networks and applications; for that purpose, it is useful to
derive the `SignKey` directly. 

```rust
let seed_phrase = b"Do not hard-code this phrase, usually it's always good to\
                    import it from safe password-protected storage,\
                    or a hardware security module";
let private_key = SignKey::new(Some(seed_phrase));
```

Then, if say the user needs a public key for Network A, they can
derive the `VerKey` in place:

```rust
let public_key = VerKey::new(network_a_generator_point, &private_key);
```

Here note that we recommend using a longer seed phrase for the
exchange. The phrase must be at least `32` bytes long, otherwise the
cryptography is compromised. 

### Signature verification example

After having generated the keys it is time to walk through an example
of sig-verify. 


```rust
let message = b"Hello world!";

// New and session-local generator point.  These generator points can
// be exchanged periodically alongside the `VerKey`s correspoding to
// the same accounts.  It is not possible to derive a new `VerKey`
// given the old `GeneratorPoint` and the new `GeneratorPoint`.
let gen = GeneratorPoint::new();

// Random seed is the most cryptographically secure.  Explicitly not
// using a seed allows efficient internal randomisation.
let sign_key = SignKey::new(None).unwrap();
let ver_key = VerKey::new(gen, &sign_key);

let signature = sign_key.sign(&message).unwrap();
// TODO: it is also natural to expect `message`.sign(&sign_key)`. 

assert!(
    signature.verify(&message, &ver_key, gen).unwrap(),
    "Failed to verify signature for message [1,2,3,4,5]"
);

let different_message = [2, 3, 4, 5, 6];

let different_message_signature = sign_key.sign(&different_message).unwrap();
assert!(
    different_message_signature
    .verify(&different_message, &ver_key, gen)
    .unwrap(),
    "Couldn't verify the signature on `different_message`, probably because the signature has become non-deterministic."
);
assert!(!different_message_signature
    .verify(&message, &ver_key, gen)
    .unwrap(),
    "The signature for two different trivial messages is the exact same. This should never happen, and you should report it"
);

```

In the first line we are generating a session for the exchange, in a
real example, one would have to separately exchange the
`GeneratorPoint`, the `ver_key`, and the message should come with
neither of those things.  It is also possible that the `gen` is
pre-existing and all parties have exchanged the seed phrase before
initiating the exchange. 

### Using the Instruction

As is, the implementation is compiled to a BPF representation and
statically linked against the Solana program that wishes to either
sign or verify the messages.  This is relatively efficient for single
signatures, and is effectively the same overhead as one would expect
from a Solana native program.  However there are instances, where it
might be useful to define a Solana native program that handles the
Signing and verification parts of the exchange. 

For this purpose, an example Solana program is provided that utilises
the features exposed in the modification.  It is by far not complete,
and had not been extensively tested, to the effect, that no behaviour
outside the ones tested in `bls12_381_instruction.rs::sig_verify` were
tested. 



# Code Details

In this section I shall explain some of the aspects of the
implementation so that the code is easier to maintain. 
